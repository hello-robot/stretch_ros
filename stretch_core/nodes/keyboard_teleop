#!/usr/bin/env python
from __future__ import print_function

import time
import math
import curses
import keyboard as kb
import argparse as ap

import rospy
import rosnode
from roscpp.srv import SetLoggerLevel, SetLoggerLevelRequest
from std_srvs.srv import Trigger, TriggerRequest
from sensor_msgs.msg import JointState
from control_msgs.msg import FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectoryPoint

import hello_helpers.hello_misc as hm


class GetKeyboardCommands:

    def __init__(self, mapping_on, hello_world_on, open_drawer_on, clean_surface_on, grasp_object_on, deliver_object_on):
        self.mapping_on = mapping_on
        self.hello_world_on = hello_world_on
        self.open_drawer_on = open_drawer_on
        self.clean_surface_on = clean_surface_on
        self.grasp_object_on = grasp_object_on
        self.deliver_object_on = deliver_object_on

        self.step_size = 'medium'
        # self.persistent_command_count = 0
        # self.prev_persistent_c = None
        # self.persistent_start_s = time.time()
        # self.max_persistent_delay_s = 1.0
        self.rad_per_deg = math.pi/180.0
        self.small_deg = 3.0
        self.small_rad = self.rad_per_deg * self.small_deg
        self.small_translate = 0.005  #0.02
        self.medium_deg = 6.0
        self.medium_rad = self.rad_per_deg * self.medium_deg
        self.medium_translate = 0.04
        self.big_deg = 12.0
        self.big_rad = self.rad_per_deg * self.big_deg
        self.big_translate = 0.06
        self.mode = 'position' #'manipulation' #'navigation'

    def get_deltas(self):
        if self.step_size == 'small':
            deltas = {'rad': self.small_rad, 'translate': self.small_translate}
        if self.step_size == 'medium':
            deltas = {'rad': self.medium_rad, 'translate': self.medium_translate} 
        if self.step_size == 'big':
            deltas = {'rad': self.big_rad, 'translate': self.big_translate} 
        return deltas

    def setup_screen(self, screen):
        if screen is not None:
            maxy, maxx = screen.getmaxyx()
            self.menu_window = screen.subwin(maxy, maxx - int(maxx / 2), 0, int(maxx / 2))
            self.log_window = screen.subwin(maxy, int(maxx / 2), 0, 0)

    def print_commands(self, screen, joints=['joint_head_tilt', 'joint_head_pan', 'translate_mobile_base', 'joint_lift', 'wrist_extension', 'joint_wrist_yaw', 'gripper_aperture']):
        def in_joints(i):
            return len(list(set(i) & set(joints))) > 0

        if screen is None:
            print('---------- KEYBOARD TELEOP MENU -----------')
            print('                                           ')
            print('              i HEAD UP                    ')
            print(' j HEAD LEFT            l HEAD RIGHT       ')
            print('              , HEAD DOWN                  ')
            print('                                           ')
            print('                                           ')
            print(' 7 BASE ROTATE LEFT     9 BASE ROTATE RIGHT')
            print(' home                   page-up            ')
            print('                                           ')
            print('                                           ')
            print('              8 LIFT UP                    ')
            print('              up-arrow                     ')
            print(' 4 BASE FORWARD         6 BASE BACK        ')
            print(' left-arrow             right-arrow        ')
            print('              2 LIFT DOWN                  ')
            print('              down-arrow                   ')
            print('                                           ')
            print('                                           ')
            print('              w ARM OUT                    ')
            print(' a WRIST FORWARD        d WRIST BACK       ')
            print('              x ARM IN                     ')
            print('                                           ')
            print('                                           ')
            print('              5 GRIPPER CLOSE              ')
            print('              0 GRIPPER OPEN               ')
            print('                                           ')
            print('  step size:  b BIG, m MEDIUM, s SMALL     ')
            print('                                           ')
            print('              q QUIT                       ')
            print('                                           ')
            print('-------------------------------------------')
        else:
            screen.erase()
            self.menu_window.erase()
            self.log_window.erase()

            self.menu_window.border(0)
            self.log_window.border(0)

            maxy, maxx = self.menu_window.getmaxyx()
            def centerx(msg):
                return int((maxx - len(msg)) / 2)

            msg = ' KEYBOARD TELEOP MENU '
            self.menu_window.addstr(0, centerx(msg), msg)

            # other
            msg = 'step size:  b BIG, m MEDIUM, s SMALL'
            self.menu_window.addstr(2, centerx(msg), msg)
            msg = 'q QUIT'
            self.menu_window.addstr(3, centerx(msg), msg)

            # head joints
            if in_joints(['joint_head_tilt']):
                msg = 'i HEAD UP'
                self.menu_window.addstr(5, centerx(msg), msg)
            if in_joints(['joint_head_pan']):
                msg = 'j HEAD LEFT                   l HEAD RIGHT'
                self.menu_window.addstr(6, centerx(msg), msg)
            if in_joints(['joint_head_tilt']):
                msg = ', HEAD DOWN'
                self.menu_window.addstr(7, centerx(msg), msg)

            # base rotate
            bjoints = ['translate_mobile_base', 'rotate_mobile_base']
            if in_joints(bjoints):
                msg = '7 BASE ROTATE LEFT     9 BASE ROTATE RIGHT'
                self.menu_window.addstr(10, centerx(msg), msg)
                msg = 'home                               page-up'
                self.menu_window.addstr(11, centerx(msg), msg)

            # base translate and lift
            if in_joints(['joint_lift']):
                msg = '8 LIFT UP'
                self.menu_window.addstr(14, centerx(msg), msg)
                msg = 'up-arrow'
                self.menu_window.addstr(15, centerx(msg), msg)
            if in_joints(bjoints):
                msg = '4 BASE FORWARD                 6 BASE BACK'
                self.menu_window.addstr(16, centerx(msg), msg)
                msg = 'left-arrow                     right-arrow'
                self.menu_window.addstr(17, centerx(msg), msg)
            if in_joints(['joint_lift']):
                msg = '2 LIFT DOWN'
                self.menu_window.addstr(18, centerx(msg), msg)
                msg = 'down-arrow'
                self.menu_window.addstr(19, centerx(msg), msg)

            # arm and wrist yaw joints
            ajoints = ['joint_arm_l3', 'joint_arm_l2', 'joint_arm_l1', 'joint_arm_l0', 'wrist_extension']
            if in_joints(ajoints):
                msg = 'w ARM OUT'
                self.menu_window.addstr(22, centerx(msg), msg)
            if in_joints(['joint_wrist_yaw']):
                msg = 'a WRIST FORWARD               d WRIST BACK'
                self.menu_window.addstr(23, centerx(msg), msg)
            if in_joints(ajoints):
                msg = 'x ARM IN'
                self.menu_window.addstr(24, centerx(msg), msg)

            # gripper joint
            gjoints = ['joint_gripper_finger_left', 'joint_gripper_finger_right', 'gripper_aperture']
            if in_joints(gjoints):
                msg = '5 GRIPPER CLOSE'
                self.menu_window.addstr(27, centerx(msg), msg)
                msg = '0 GRIPPER OPEN'
                self.menu_window.addstr(28, centerx(msg), msg)

            # services
            msg = '---------------- SERVICES ----------------'
            self.menu_window.addstr(30, centerx(msg), msg)

            # TODO: change space into stop the robot, and give service p instead
            msg = 'space STOP THE ROBOT'
            first_service_x = centerx(msg)
            self.menu_window.addstr(32, first_service_x - len('spac'), msg)

            self.mapping_on = True # TODO remove
            if self.mapping_on:
                msg = 'p PERFORM 360 3D SCAN'
                self.menu_window.addstr(33, first_service_x, msg)
                msg = '\ DRIVE TO NEXT BEST PLACE TO SCAN'
                self.menu_window.addstr(34, first_service_x, msg)
                msg = '- LOCAL LOCALIZATION'
                self.menu_window.addstr(35, first_service_x, msg)
                msg = '+ GLOBAL LOCALIZATION'
                self.menu_window.addstr(36, first_service_x, msg)
                msg = '{ ROTATE TO ALIGN W/ NEAREST 3D CLIFF'
                self.menu_window.addstr(37, first_service_x, msg)
                msg = '} EXTEND ARM UNTIL CONTACT'
                self.menu_window.addstr(38, first_service_x, msg)


            self.menu_window.refresh()
            self.log_window.refresh()
            screen.refresh()

    def get_command(self, node):
        command = None

        c = kb.getch()
        #rospy.loginfo('c =', c)
        
        ####################################################
        ## MOSTLY MAPPING RELATED CAPABILITIES
        ## (There are non-mapping outliers.)
        ####################################################
        
        # Sequential performs a fixed number of autonomus mapping iterations
        if (c == '!') and self.mapping_on:
            number_iterations = 4
            for n in range(number_iterations):
                # Trigger a 3D scan with the D435i
                trigger_request = TriggerRequest() 
                trigger_result = node.trigger_head_scan_service(trigger_request)
                rospy.loginfo('trigger_result = {0}'.format(trigger_result))

                # Trigger driving the robot to the estimated next best place to scan
                trigger_request = TriggerRequest() 
                trigger_result = node.trigger_drive_to_scan_service(trigger_request)
                rospy.loginfo('trigger_result = {0}'.format(trigger_result))
                
        # Trigger localizing the robot to a new pose anywhere on the current map
        if ((c == '+') or (c == '=')) and self.mapping_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_global_localization_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # Trigger localizing the robot to a new pose that is near its current pose on the map
        if ((c == '-') or (c == '_')) and self.mapping_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_local_localization_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # Trigger driving the robot to the estimated next best place to perform a 3D scan
        if ((c == '\\') or (c == '|')) and self.mapping_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_drive_to_scan_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # Trigger performing a 3D scan using the D435i
        if (c == ' ') and self.mapping_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_head_scan_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # Trigger rotating the mobile base to align with the nearest 3D cliff detected visually
        if ((c == '[') or (c == '{')) and self.mapping_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_align_with_nearest_cliff_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # DEPRECATED: Trigger extend arm until contact
        if ((c == ']') or (c == '}')) and self.mapping_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_reach_until_contact_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # DEPRECATED: Trigger lower arm until contact
        if ((c == ':') or (c == ';')) and self.mapping_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_lower_until_contact_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))
            
        
        ####################################################
        ## OTHER CAPABILITIES
        ####################################################

        # Trigger Hello World whiteboard writing demo
        if ((c == '`') or (c == '~')) and self.hello_world_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_write_hello_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # Trigger open drawer demo with downward hook motion
        if ((c == 'z') or (c == 'Z')) and self.open_drawer_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_open_drawer_down_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # Trigger open drawer demo with upward hook motion
        if ((c == '.') or (c == '>')) and self.open_drawer_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_open_drawer_up_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # Trigger clean surface demo
        if ((c == '/') or (c == '?')) and self.clean_surface_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_clean_surface_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))
            
        # Trigger grasp object demo    
        if ((c == '\'') or (c == '\"')) and self.grasp_object_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_grasp_object_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

        # Trigger deliver object demo    
        if ((c == 'y') or (c == 'Y')) and self.deliver_object_on:
            trigger_request = TriggerRequest() 
            trigger_result = node.trigger_deliver_object_service(trigger_request)
            rospy.loginfo('trigger_result = {0}'.format(trigger_result))

            
        ####################################################
        ## BASIC KEYBOARD TELEOPERATION COMMANDS
        ####################################################
        
        # 8 or up arrow
        if c == '8' or c == '\x1b[A':
            command = {'joint': 'joint_lift', 'delta': self.get_deltas()['translate']}
        # 2 or down arrow
        if c == '2' or c == '\x1b[B':
            command = {'joint': 'joint_lift', 'delta': -self.get_deltas()['translate']}
        if self.mode == 'manipulation':
            # 4 or left arrow
            if c == '4' or c == '\x1b[D':
                command = {'joint': 'joint_mobile_base_translation', 'delta': self.get_deltas()['translate']}
            # 6 or right arrow
            if c == '6' or c == '\x1b[C':
                command = {'joint': 'joint_mobile_base_translation', 'delta': -self.get_deltas()['translate']}
        elif self.mode == 'position':
            # 4 or left arrow
            if c == '4' or c == '\x1b[D':
                command = {'joint': 'translate_mobile_base', 'inc': self.get_deltas()['translate']}
            # 6 or right arrow
            if c == '6' or c == '\x1b[C':
                command = {'joint': 'translate_mobile_base', 'inc': -self.get_deltas()['translate']}
            # 1 or end key 
            if c == '7' or c == '\x1b[H':
                command = {'joint': 'rotate_mobile_base', 'inc': self.get_deltas()['rad']}
            # 3 or pg down 5~
            if c == '9' or c == '\x1b[5':
                command = {'joint': 'rotate_mobile_base', 'inc': -self.get_deltas()['rad']}
        elif self.mode == 'navigation':
            rospy.loginfo('ERROR: Navigation mode is not currently supported.')

        if c == 'w' or c == 'W':
            command = {'joint': 'wrist_extension', 'delta': self.get_deltas()['translate']}
        if c == 'x' or c == 'X':
            command = {'joint': 'wrist_extension', 'delta': -self.get_deltas()['translate']}
        if c == 'd' or c == 'D':
            command = {'joint': 'joint_wrist_yaw', 'delta': -self.get_deltas()['rad']}
        if c == 'a' or c == 'A':
            command = {'joint': 'joint_wrist_yaw', 'delta': self.get_deltas()['rad']}
        if c == '5' or c == '\x1b[E' or c == 'g' or c == 'G':
            # grasp
            command = {'joint': 'joint_gripper_finger_left', 'delta': -self.get_deltas()['rad']}
        if c == '0' or c == '\x1b[2' or c == 'r' or c == 'R':
            # release
            command = {'joint': 'joint_gripper_finger_left', 'delta': self.get_deltas()['rad']}
        if c == 'i' or c == 'I':
            command = {'joint': 'joint_head_tilt', 'delta': (2.0 * self.get_deltas()['rad'])}
        if c == ',' or c == '<':
            command = {'joint': 'joint_head_tilt', 'delta': -(2.0 * self.get_deltas()['rad'])}
        if c == 'j' or c == 'J':
            command = {'joint': 'joint_head_pan', 'delta': (2.0 * self.get_deltas()['rad'])}
        if c == 'l' or c == 'L':
            command = {'joint': 'joint_head_pan', 'delta': -(2.0 * self.get_deltas()['rad'])}
        if c == 'b' or c == 'B':
            rospy.loginfo('process_keyboard.py: changing to BIG step size')
            self.step_size = 'big'
        if c == 'm' or c == 'M':
            rospy.loginfo('process_keyboard.py: changing to MEDIUM step size')
            self.step_size = 'medium'
        if c == 's' or c == 'S':
            rospy.loginfo('process_keyboard.py: changing to SMALL step size')
            self.step_size = 'small'
        if c == 'q' or c == 'Q':
            rospy.loginfo('keyboard_teleop exiting...')
            rospy.signal_shutdown('Received quit character (q), so exiting')

        ####################################################

        return command


class KeyboardTeleopNode(hm.HelloNode):

    def __init__(self, screen=None, mapping_on=False, hello_world_on=False, open_drawer_on=False, clean_surface_on=False, grasp_object_on=False, deliver_object_on=False):
        hm.HelloNode.__init__(self)
        self.keys = GetKeyboardCommands(mapping_on, hello_world_on, open_drawer_on, clean_surface_on, grasp_object_on, deliver_object_on)
        self.rate = 10.0
        self.joint_state = None
        self.screen = screen
        self.mapping_on = mapping_on
        self.hello_world_on = hello_world_on
        self.open_drawer_on = open_drawer_on
        self.clean_surface_on = clean_surface_on
        self.grasp_object_on = grasp_object_on
        self.deliver_object_on = deliver_object_on

    def joint_states_callback(self, joint_state):
        self.joint_state = joint_state

    def send_command(self, command):
        joint_state = self.joint_state
        if (joint_state is not None) and (command is not None):
            point = JointTrajectoryPoint()
            point.time_from_start = rospy.Duration(0.0)
            trajectory_goal = FollowJointTrajectoryGoal()
            trajectory_goal.goal_time_tolerance = rospy.Time(1.0)
            
            joint_name = command['joint']
            trajectory_goal.trajectory.joint_names = [joint_name]
            if 'inc' in command:
                inc = command['inc']
                rospy.loginfo('inc = {0}'.format(inc))
                new_value = inc
            elif 'delta' in command:
                joint_index = joint_state.name.index(joint_name)
                joint_value = joint_state.position[joint_index]
                delta = command['delta']
                rospy.loginfo('delta = {0}, joint_index = {1}, joint_value = {2}'.format(delta, joint_index, joint_value))
                new_value = joint_value + delta
            point.positions = [new_value]
            trajectory_goal.trajectory.points = [point]
            trajectory_goal.trajectory.header.stamp = rospy.Time.now()
            rospy.loginfo('joint_name = {0}, trajectory_goal = {1}'.format(joint_name, trajectory_goal))
            self.trajectory_client.send_goal(trajectory_goal)
            rospy.loginfo('Done sending pose.')

    def main(self):
        hm.HelloNode.main(self, 'keyboard_teleop', 'keyboard_teleop', wait_for_first_pointcloud=False, quiet=self.screen is not None)

        if self.mapping_on: 
            rospy.loginfo('Node ' + self.node_name + ' waiting to connect to /funmap/trigger_head_scan.')

            rospy.wait_for_service('/funmap/trigger_head_scan')
            rospy.loginfo('Node ' + self.node_name + ' connected to /funmap/trigger_head_scan.')
            self.trigger_head_scan_service = rospy.ServiceProxy('/funmap/trigger_head_scan', Trigger)

            rospy.wait_for_service('/funmap/trigger_drive_to_scan')
            rospy.loginfo('Node ' + self.node_name + ' connected to /funmap/trigger_drive_to_scan.')
            self.trigger_drive_to_scan_service = rospy.ServiceProxy('/funmap/trigger_drive_to_scan', Trigger)

            rospy.wait_for_service('/funmap/trigger_global_localization')
            rospy.loginfo('Node ' + self.node_name + ' connected to /funmap/trigger_global_localization.')
            self.trigger_global_localization_service = rospy.ServiceProxy('/funmap/trigger_global_localization', Trigger)

            rospy.wait_for_service('/funmap/trigger_local_localization')
            rospy.loginfo('Node ' + self.node_name + ' connected to /funmap/trigger_local_localization.')
            self.trigger_local_localization_service = rospy.ServiceProxy('/funmap/trigger_local_localization', Trigger)

            rospy.wait_for_service('/funmap/trigger_align_with_nearest_cliff')
            rospy.loginfo('Node ' + self.node_name + ' connected to /funmap/trigger_align_with_nearest_cliff.')
            self.trigger_align_with_nearest_cliff_service = rospy.ServiceProxy('/funmap/trigger_align_with_nearest_cliff', Trigger)

            rospy.wait_for_service('/funmap/trigger_reach_until_contact')
            rospy.loginfo('Node ' + self.node_name + ' connected to /funmap/trigger_reach_until_contact.')
            self.trigger_reach_until_contact_service = rospy.ServiceProxy('/funmap/trigger_reach_until_contact', Trigger)

            rospy.wait_for_service('/funmap/trigger_lower_until_contact')
            rospy.loginfo('Node ' + self.node_name + ' connected to /funmap/trigger_lower_until_contact.')
            self.trigger_lower_until_contact_service = rospy.ServiceProxy('/funmap/trigger_lower_until_contact', Trigger)

        if self.hello_world_on: 
            rospy.wait_for_service('/hello_world/trigger_write_hello')
            rospy.loginfo('Node ' + self.node_name + ' connected to /hello_world/trigger_write_hello.')
            self.trigger_write_hello_service = rospy.ServiceProxy('/hello_world/trigger_write_hello', Trigger)

        if self.open_drawer_on:
            rospy.wait_for_service('/open_drawer/trigger_open_drawer_down')
            rospy.loginfo('Node ' + self.node_name + ' connected to /open_drawer/trigger_open_drawer_down.')
            self.trigger_open_drawer_down_service = rospy.ServiceProxy('/open_drawer/trigger_open_drawer_down', Trigger)

            rospy.wait_for_service('/open_drawer/trigger_open_drawer_up')
            rospy.loginfo('Node ' + self.node_name + ' connected to /open_drawer/trigger_open_drawer_up.')
            self.trigger_open_drawer_up_service = rospy.ServiceProxy('/open_drawer/trigger_open_drawer_up', Trigger)

        if self.clean_surface_on:
            rospy.wait_for_service('/clean_surface/trigger_clean_surface')
            rospy.loginfo('Node ' + self.node_name + ' connected to /clean_surface/trigger_clean_surface.')
            self.trigger_clean_surface_service = rospy.ServiceProxy('/clean_surface/trigger_clean_surface', Trigger)

        if self.grasp_object_on:
            rospy.wait_for_service('/grasp_object/trigger_grasp_object')
            rospy.loginfo('Node ' + self.node_name + ' connected to /grasp_object/trigger_grasp_object.')
            self.trigger_grasp_object_service = rospy.ServiceProxy('/grasp_object/trigger_grasp_object', Trigger)

        if self.deliver_object_on:
            rospy.wait_for_service('/deliver_object/trigger_deliver_object')
            rospy.loginfo('Node ' + self.node_name + ' connected to /deliver_object/trigger_deliver_object.')
            self.trigger_deliver_object_service = rospy.ServiceProxy('/deliver_object/trigger_deliver_object', Trigger)

        rospy.Subscriber('/stretch/joint_states', JointState, self.joint_states_callback)

        rate = rospy.Rate(self.rate)

        self.keys.setup_screen(self.screen)
        while not rospy.is_shutdown():
            self.keys.print_commands(self.screen)
            if self.screen is None:
                command = self.keys.get_command(self)
                rospy.loginfo(command)
                self.send_command(command)
            rate.sleep()

def main(screen, args):
    try:
        # initial curses settings
        if screen is not None:
            curses.use_default_colors()
            curses.curs_set(0)
            screen.nodelay(1) # getch non-blocking

        node = KeyboardTeleopNode(screen,
            args.mapping_on, args.hello_world_on,
            args.open_drawer_on, args.clean_surface_on,
            args.grasp_object_on, args.deliver_object_on)
        node.main()
    except KeyboardInterrupt:
        rospy.loginfo('interrupt received, so shutting down')

if __name__ == '__main__':
    # collect command line arguments
    parser = ap.ArgumentParser(description='Keyboard teleoperation for stretch.')
    parser.add_argument('--legacy', action='store_true', help='Run this node in legacy appending behavior. Functionally equivalent to before pretty printing was introduced to this node.')
    parser.add_argument('--mapping_on', action='store_true', help='Turn on mapping control. For example, the space bar will trigger a head scan. This requires that the mapping node be run (funmap).')
    parser.add_argument('--hello_world_on', action='store_true', help='Enable Hello World writing trigger, which requires connection to the appropriate hello_world service.')
    parser.add_argument('--open_drawer_on', action='store_true', help='Enable Open Drawer trigger, which requires connection to the appropriate open_drawer service.')
    parser.add_argument('--clean_surface_on', action='store_true', help='Enable Clean Surface trigger, which requires connection to the appropriate clean_surface service.')
    parser.add_argument('--grasp_object_on', action='store_true', help='Enable Grasp Object trigger, which requires connection to the appropriate grasp_object service.')
    parser.add_argument('--deliver_object_on', action='store_true', help='Enable Deliver Object trigger, which requires connection to the appropriate deliver_object service.')
    args, unknown = parser.parse_known_args()

    if args.legacy:
        # launch keyboard teleop without a curses screen
        main(None, args)
    else:
        # disable logging from all other nodes as it interferes with pretty teleop
        time.sleep(1)
        for node in rosnode.get_node_names():
            topic = '{0}/set_logger_level'.format(node)
            rospy.wait_for_service(topic)
            trigger = rospy.ServiceProxy(topic, SetLoggerLevel)
            trigger(SetLoggerLevelRequest(logger='rosout', level='fatal'))

        # launch keyboard teleop
        curses.wrapper(main, args)
